enum Option<T> {
    None,
    Some T,
}

let from = fn x -> x << @(from (x+1))

let nats = from 0

let when = fn pred xs ->
  match xs with {
    x << xs => 
      if !#pred x then
        Some(from 0) << @(when pred !@xs)
      else 
        (None) << @(when pred !@xs)
  }

let switch = fn xs es -> 
  match (xs, es) with {
    (x << xs, e << es) => match e with {
      None => x << @(switch !@xs !@es),
      Some (a << as) => a << @(switch !@as !@es)
    }
  }

let loop_10 = switch nats (when #(fn x -> x % 10 == 0) nats)

let head = fn stream -> 
  match stream with {
    x << xs => x
  }

let print_loop_10 = print_int ((head loop_10), "loop_10") << @print_loop_10

let print_contains = {
  let contains = fn xs v -> 
    match xs with {
      [] => false,
      x::xs => 
        if v == x then
          true
        else 
          contains xs v
    };
  (if contains [0,1,2,3,4] (head loop_10) then print_int ((head loop_10), "contains") else ()) << @print_contains
}

let chicken = 
  (match egg with {
    x<<egg => if x == 0 then true else false,
  }) << @chicken
and egg = 
  (match chicken with {
      x<<chicken => if x then 1 else 0,
    }) << @egg
with 0

let print_egg = (print_int ((head egg), "egg")) << @print_egg
