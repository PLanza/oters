use crate::parser::ast::{Expr, Opcode, TypeExpr, Pattern};

use std::str::FromStr;

use lalrpop_util::ParseError;

grammar;

// -------------------- Utils -------------------- 

// A comma separated list with minimum one element and optional trailing comma
Comma<T>: Vec<T> = {
    <t: T> <mut v: ("," <T>)*> ","? => { 
      v.insert(0, t);
      v
    }
}

FieldItem<T>: (String, T) = {
  <i: LowerId> ":" <e: T> => (i, e)
};

Fields<T>: Vec<(String, T)> = {
  "{}" => Vec::new(),
  "{" <Comma<FieldItem<T>>> "}"
};

// -------------------- Identifiers -------------------- 

LowerId: String = {
  <s: r"[a-z][A-Za-z0-9'_]*"> => s.to_string()
}

UpperId: String = {
  <s: r"[A-Z][A-Za-z0-9'_]*"> => s.to_string()
}


// -------------------- Literals -------------------- 

True: () = {
  "true" => (),
};
False: () = {
  "false" => (),
};

Int: i64 = {
  r"-?[0-9]+" =>? i64::from_str(<>)
    .map_err(|_| ParseError::User {
      error: "Integer overflow"
    })
};

Float: f64 = {
  r"-?[0-9]+\.[0-9]*" =>? f64::from_str(<>)
    .map_err(|e| ParseError::User {
      error: "Float overflow"
    })
};

String: String = {
  <s: r#""(\\"|[^"])*""#> => {
    let mut chars = s.chars();
    chars.next();
    chars.next_back();
    let s = chars.as_str();
    s.replace(r#"\\\""#, r#"\""#)
  }
};

Unit: () = {
  r"\(\)" => (),
};

// -------------------- Types --------------------
// Presented with lowest precedence at the top

FixType: Box<TypeExpr> = {
  "fix" <v: LowerId> "->" <t: FixType> => Box::new(TypeExpr::TEFix(v,t)),
  FunctionType,
}

FunctionType: Box<TypeExpr> = {
  <PrefixType> "->" <FunctionType> => Box::new(TypeExpr::TEFunction(<>)),
  PrefixType,
};

PrefixType: Box<TypeExpr> = {
  "@" <PrefixType> => Box::new(TypeExpr::TEDelay(<>)),
  "#" <PrefixType> => Box::new(TypeExpr::TEStable(<>)),
  TypeTerm,
};

// Minimum of 2 elements
TupleType: Box<TypeExpr> = {
  "(" <t: Type> "," <mut v: Comma<Type>> ")" => {
    v.insert(0, t);
    Box::new(TypeExpr::TETuple(v))
  }
};

GenericArgs: Vec<Box<TypeExpr>> = {
  "<" <Comma<Type>> ">"
};

UserType: Box<TypeExpr> = {
  UpperId => Box::new(TypeExpr::TEUser(<>,Vec::new())),
  UpperId GenericArgs => Box::new(TypeExpr::TEUser(<>))
};

TypeTerm: Box<TypeExpr> = { 
  "bool" => Box::new(TypeExpr::TEBool),
  "int" => Box::new(TypeExpr::TEInt),
  "float" => Box::new(TypeExpr::TEFloat),
  "string" => Box::new(TypeExpr::TEString),
  Unit => Box::new(TypeExpr::TEUnit),
  TupleType,
  "[" <Type> "]" => Box::new(TypeExpr::TEList(<>)),
  UserType,
  LowerId => Box::new(TypeExpr::TEVar(<>)),
  "(" <Type> ")",
};

pub Type: Box<TypeExpr> = FixType;

 
// -------------------- Operators --------------------
// Grouped by Precedence

CompOp: Opcode = {
  "==" => Opcode::Eq,
  "<" => Opcode::Lt,
  ">" => Opcode::Gt,
};

ConsStreamOp: Opcode = {
  "::" => Opcode::Cons,
  "<<" => Opcode::Stream,
};

AddSubOp: Opcode = {
  "+" => Opcode::Add,
  "-" => Opcode::Sub,
};

MulDivModOp: Opcode = {
  "*" => Opcode::Mul,
  "/" => Opcode::Div,
  "%" => Opcode::Mod,
};

PrefixOp: Opcode = {
  "~" => Opcode::Neg,
  "!" => Opcode::Not,
  "@" => Opcode::Delay,
  "#" => Opcode::Stable,
  "!@" => Opcode::Adv,
  "!#" => Opcode::Unbox,
  "out" => Opcode::Out,
  "into" => Opcode::Into,
};

// -------------------- Operator Expressions --------------------  
// Lowest precedence at the top

// Right associative 
OrExpr: Box<Expr> = {
  <e1: AndExpr> "||" <e2: OrExpr> => Box::new(Expr::BinOp(e1, Opcode::Or, e2)),
  AndExpr
};

// Right associative 
AndExpr: Box<Expr> = {
  <e1: Comp> "&&" <e2: AndExpr> => Box::new(Expr::BinOp(e1, Opcode::And, e2)),
  Comp
};

// Left associative 
Comp: Box<Expr> = {
  Comp CompOp ConsStream => Box::new(Expr::BinOp(<>)),
  ConsStream
};

// Right associative 
ConsStream: Box<Expr> = {
  AddSub ConsStreamOp ConsStream => Box::new(Expr::BinOp(<>)),
  AddSub
};

// Left associative 
AddSub: Box<Expr> = {
  AddSub AddSubOp MulDivMod => Box::new(Expr::BinOp(<>)),
  MulDivMod
};

// Left associative 
MulDivMod: Box<Expr> = {
  MulDivMod MulDivModOp AppExpr => Box::new(Expr::BinOp(<>)),
  AppExpr
};

// Left associative 
AppExpr: Box<Expr> = {
  <AppExpr> <VariantStructExpr> => Box::new(Expr::App(<>)),
  VariantStructExpr,
};

VariantStructExpr: Box<Expr> = {
  <s: UpperId> <e: VariantStructExpr> => Box::new(Expr::Variant(s, Some(e))),
  <s: UpperId> <f: Fields<Expr>> => Box::new(Expr::StructExpr(s, f)), 
  DotExpr
}

// Left associative 
DotExpr: Box<Expr> = {
  <DotExpr> "." <Int> => Box::new(Expr::ProjTuple(<>)),
  <DotExpr> "." <LowerId> => Box::new(Expr::ProjStruct(<>)),
  Prefix
};

Prefix: Box<Expr> = {
  PrefixOp Prefix => Box::new(Expr::UnOp(<>)),
  Term,
};

// -------------------- Terms -------------------- 
// The simplest expressions

ListTerm: Box<Expr> = {
  "[]" => Box::new(Expr::List(Vec::new())),
  "[" <v: Comma<Expr>> "]" => Box::new(Expr::List(v)),
};

TupleTerm: Box<Expr> = {
  "(" <e: Expr> "," <mut v: Comma<Expr>> ")" => {
    v.insert(0, e);
    Box::new(Expr::Tuple(v))
  }
};

Term: Box<Expr> = { 
  True => Box::new(Expr::True),
  False => Box::new(Expr::False),
  Int => Box::new(Expr::Int(<>)),
  Float => Box::new(Expr::Float(<>)),
  String => Box::new(Expr::String(<>)),
  Unit => Box::new(Expr::Unit),
  ListTerm,
  TupleTerm,
  LowerId => Box::new(Expr::Var(<>)),
  "(" <Expr> ")",
};

// -------------------- Patterns -------------------- 
// Lowest precedence at the top

// Left associative
OrPattern: Box<Pattern> = {
  <OrPattern> "|" <ConsPattern> => Box::new(Pattern::Or(<>)),
  ConsPattern,
};

// Right associative
ConsPattern: Box<Pattern> = {
  <PatternTerm> "::" <ConsPattern> => Box::new(Pattern::Cons(<>)),
  <PatternTerm> "<<" <ConsPattern> => Box::new(Pattern::Stream(<>)),
  PrefixPattern,
};

PrefixPattern: Box<Pattern> = {
  "@" <PrefixPattern> => Box::new(Pattern::Delay(<>)),
  "#" <PrefixPattern> => Box::new(Pattern::Stable(<>)),
  PatternTerm,
}

ListPattern: Box<Pattern> = {
  "[]" => Box::new(Pattern::List(Vec::new())),
  "[" <v: Comma<Pattern>> "]" => Box::new(Pattern::List(v))
}

TuplePattern: Box<Pattern> = {
  "(" <e: Pattern> "," <mut v: Comma<Pattern>> ")" => {
    v.insert(0, e);
    Box::new(Pattern::Tuple(v))
  }
};

StructPatternItem: (String, Option<Box<Pattern>>) = {
  <i: LowerId> ":" <p: Pattern> => (i, Some(p)),
  <i: LowerId> => (i, None),
  ".." => ("..".to_string(), None)
};

StructPatternList: Vec<(String, Option<Box<Pattern>>)> = {
  "{}" => Vec::new(),
  "{" <Comma<StructPatternItem>> "}",
};

StructPattern: Box<Pattern> = {
  <s: UpperId> <v: StructPatternList> => Box::new(Pattern::Struct(s, v))
};

PatternTerm: Box<Pattern> = {
  "_" => Box::new(Pattern::Underscore),
  True => Box::new(Pattern::True),
  False => Box::new(Pattern::False),
  Int => Box::new(Pattern::Int(<>)),
  Float => Box::new(Pattern::Float(<>)),
  String => Box::new(Pattern::String(<>)),
  Unit => Box::new(Pattern::Unit),
  <s: UpperId> <p: PatternTerm> => Box::new(Pattern::Variant(s, Some(p))),
  <UpperId> => Box::new(Pattern::Variant(<>, None)),
  TuplePattern, 
  ListPattern,
  StructPattern,
  <LowerId> => Box::new(Pattern::Var(<>)),
  "(" <Pattern> ")",
}

Pattern: Box<Pattern> = OrPattern;

// -------------------- Expressions -------------------- 

OpExpr = OrExpr;

BlockTerm: Box<Expr> = {
  <LetExpr> ";",
  <e: Expr> ";" => e
};

BlockExpr: Box<Expr> =  {
  "{" <mut v: BlockTerm*> <r: Expr> "}" => {
    v.push(r);
    Box::new(Expr::Block(v))
  }
};

IfExpr: Box<Expr> = {
  "if" <e1: Expr> "then" <e2: Expr> "else" <e3: Expr> => Box::new(Expr::If(e1, e2, e3))
};

FnArg: (String, Box<TypeExpr>) = {
  "(" <i: LowerId> ":" <t: Type> ")" => (i, t),
  // Add pattern variants for Lists, Tuples, Streams
};

FnArgList: Vec<(String, Box<TypeExpr>)> = {
  <v: FnArg+> => v,
};

FnExpr: Box<Expr> = {
  "fn" Unit "->" <e: Expr> => Box::new(Expr::Fn(vec![("_".to_string(), Box::new(TypeExpr::TEUnit))], e)),
  "fn" <a: FnArgList> "->" <e: Expr> => Box::new(Expr::Fn(a, e)),
};

FixExpr: Box<Expr> = {
  "fix" <LowerId> "->" <Expr> => Box::new(Expr::Fix(<>)),
};

MatchItem: (Box<Pattern>, Box<Expr>) = {
  <Pattern> "=>" <Expr> => (<>),
};

MatchExpr: Box<Expr> = {
  "match" <e: Expr> "with" "{" <v: Comma<MatchItem>> "}" => Box::new(Expr::Match(e, v))
};

pub Expr: Box<Expr> = {
  OpExpr,
  BlockExpr,
  IfExpr,
  FnExpr,
  FixExpr,
  MatchExpr,
  <UpperId> => Box::new(Expr::Variant(<>, None)), 
};

// -------------------- Top-Level Expressions -------------------- 

LetExpr: Box<Expr> = {
  "let" <i: LowerId> "=" <e: Expr> => Box::new(Expr::Let(i, Vec::new(), e)),
  "let" <i: LowerId> <p: GenericParams> "=" <e: Expr> => Box::new(Expr::Let(i, p, e))
};

GenericParam: (bool, String) = {
  "#" <UpperId> => (true, <>),
  UpperId => (false, <>),
};

GenericParams: Vec<(bool, String)> = {
  "<" <Comma<GenericParam>> ">"
};

TypeExpr: Box<Expr> = {
  "type" <i: UpperId> "=" <t: Type> => Box::new(Expr::TypeDef(i, Vec::new(), t)),
  "type" <i: UpperId> <v: GenericParams> "=" <t: Type> => Box::new(Expr::TypeDef(i, v, t)),
};

VariantItem: (String, Option<Box<TypeExpr>>) = {
  <i: UpperId> <t: Type?> => (i, t),
};

StructExpr: Box<Expr> = {
  "struct" <i: UpperId> <f: Fields<Type>> => Box::new(Expr::StructDef(i, Vec::new(), f)),
  "struct" <i: UpperId> <p: GenericParams> <f: Fields<Type>> => 
    Box::new(Expr::StructDef(i, p, f)),
};

EnumExpr: Box<Expr> = {
  "enum" <i: UpperId> "{" <v: Comma<VariantItem>> "}" => Box::new(Expr::EnumDef(i, Vec::new(), v)),
  "enum" <i: UpperId> <p: GenericParams> "{" <v: Comma<VariantItem>> "}" => 
    Box::new(Expr::EnumDef(i, p, v)),
}

pub Item: Box<Expr> = {
  LetExpr,
  TypeExpr,
  EnumExpr,
  StructExpr,
}

pub Program: Vec<Box<Expr>> = {
  <Item*>
}
