use crate::parser::ast::{Expr, Opcode, Type, Pattern};

use std::str::FromStr;

use lalrpop_util::ParseError;

grammar;

// -------------------- Identifiers -------------------- 

LowerId: String = {
  <s: r"[a-z][A-Za-z0-9'_]*"> => s.to_string()
}

UpperId: String = {
  <s: r"[A-Z][A-Za-z0-9'_]*"> => s.to_string()
}


// -------------------- Literals -------------------- 

True: () = {
  "true" => (),
};
False: () = {
  "false" => (),
};

Int: i64 = {
  r"-?[0-9]+" =>? i64::from_str(<>)
    .map_err(|_| ParseError::User {
      error: "Integer overflow"
    })
};

Float: f64 = {
  r"-?[0-9]+\.[0-9]*" =>? f64::from_str(<>)
    .map_err(|e| ParseError::User {
      error: "Float overflow"
    })
};

String: String = {
  <s: r#""(\\"|[^"])*""#> => {
    let mut chars = s.chars();
    chars.next();
    chars.next_back();
    let s = chars.as_str();
    s.replace(r#"\\\""#, r#"\""#)
  }
};

Unit: () = {
  r"\(\)" => (),
};

// -------------------- Types --------------------

FixType: Box<Type> = {
  "fix" <v: LowerId> "->" <t: FixType> => Box::new(Type::Fix(v,t)),
  FunctionType,
}

FunctionType: Box<Type> = {
  <PrefixType> "->" <FunctionType> => Box::new(Type::Function(<>)),
  PrefixType,
};

PrefixType: Box<Type> = {
  "@" <PrefixType> => Box::new(Type::Delay(<>)),
  "#" <PrefixType> => Box::new(Type::Box(<>)),
  TypeTerm,
};

TupleType: Box<Type> = {
  "(" <t: Type> <mut v: ("," <Type>)+> ")" => {
    v.insert(0, t);
    Box::new(Type::Tuple(v))
  }
};

GenericArgs: Vec<Box<Type>> = {
  "<" <t: Type> <mut v: ("," <Type>)*> ">" => {
    v.insert(0, t);
    v
  }
};

UserType: Box<Type> = {
  UpperId => Box::new(Type::User(<>,Vec::new())),
  UpperId GenericArgs => Box::new(Type::User(<>))
};

TypeTerm: Box<Type> = { 
  True => Box::new(Type::Bool),
  False => Box::new(Type::Bool),
  "int" => Box::new(Type::Int),
  "float" => Box::new(Type::Float),
  "string" => Box::new(Type::String),
  Unit => Box::new(Type::Unit),
  TupleType,
  "[" <Type> "]" => Box::new(Type::List(<>)),
  UserType,
  LowerId => Box::new(Type::Var(<>)),
  "(" <Type> ")",
};

Type: Box<Type> = FixType;

 
// -------------------- Operators --------------------

CompOp: Opcode = {
  "==" => Opcode::Eq,
  "<" => Opcode::Lt,
  ">" => Opcode::Gt,
};

ConsStreamOp: Opcode = {
  "::" => Opcode::Cons,
  "<<" => Opcode::Stream,
};

AddSubOp: Opcode = {
  "+" => Opcode::Add,
  "-" => Opcode::Sub,
};

MulDivModOp: Opcode = {
  "*" => Opcode::Mul,
  "/" => Opcode::Div,
  "%" => Opcode::Mod,
};

PrefixOp: Opcode = {
  "~" => Opcode::Neg,
  "!" => Opcode::Not,
  "@" => Opcode::Delay,
  "#" => Opcode::Box,
  "!@" => Opcode::Adv,
  "!#" => Opcode::Unbox,
  "out" => Opcode::Out,
  "into" => Opcode::Into,
};

// -------------------- Operator Expressions --------------------  

OrExpr: Box<Expr> = {
  <e1: AndExpr> "||" <e2: OrExpr> => Box::new(Expr::BinOp(e1, Opcode::Or, e2)),
  AndExpr
};

AndExpr: Box<Expr> = {
  <e1: Comp> "&&" <e2: AndExpr> => Box::new(Expr::BinOp(e1, Opcode::And, e2)),
  Comp
};

Comp: Box<Expr> = {
  Comp CompOp ConsStream => Box::new(Expr::BinOp(<>)),
  ConsStream
};

ConsStream: Box<Expr> = {
  AddSub ConsStreamOp ConsStream => Box::new(Expr::BinOp(<>)),
  AddSub
};

AddSub: Box<Expr> = {
  AddSub AddSubOp MulDivMod => Box::new(Expr::BinOp(<>)),
  MulDivMod
};

MulDivMod: Box<Expr> = {
  MulDivMod MulDivModOp AppExpr => Box::new(Expr::BinOp(<>)),
  AppExpr
};

VariantExpr: Box<Expr> = {
  <s: UpperId> <e: VariantExpr> => Box::new(Expr::Variant(s, Some(e))),
  <UpperId> => Box::new(Expr::Variant(<>, None)), // Requires testing
  <AppExpr>
}

AppExpr: Box<Expr> = {
  <AppExpr> <DotExpr> => Box::new(Expr::App(<>)),
  DotExpr,
};

DotExpr: Box<Expr> = {
  <DotExpr> "." <Int> => Box::new(Expr::DeTuple(<>)),
  <DotExpr> "." <LowerId> => Box::new(Expr::DeStruct(<>)),
  Prefix
};

Prefix: Box<Expr> = {
  PrefixOp Prefix => Box::new(Expr::UnOp(<>)),
  Term,
};

// -------------------- Terms -------------------- 

ListTerm: Box<Expr> = {
  "[]" => Box::new(Expr::List(Vec::new())),
  "[" <e: Expr> <mut v: ("," <Expr>)*> "]" => {
    v.insert(0, e);
    Box::new(Expr::List(v))
  }
}

TupleTerm: Box<Expr> = {
  "(" <e: Expr> <mut v: ("," <Expr>)+> ")" => {
    v.insert(0, e);
    Box::new(Expr::Tuple(v))
  }
};

StructItem: (String, Box<Expr>) = {
  <i: LowerId> ":" <e: Expr> ","=> (i, e)
};

StructTermList: Vec<(String, Box<Expr>)> = {
  <v: StructItem*> => v,
  <mut v: StructItem*> <i: LowerId> ":" <e: Expr>  => {
    v.push((i,e));
    v
  },
};

StructTerm: Box<Expr> = {
  <s: UpperId> "{" <v: StructTermList> "}" => Box::new(Expr::StructVal(s, v))
};

Term: Box<Expr> = { 
  True => Box::new(Expr::True),
  False => Box::new(Expr::False),
  Int => Box::new(Expr::Int(<>)),
  Float => Box::new(Expr::Float(<>)),
  String => Box::new(Expr::String(<>)),
  Unit => Box::new(Expr::Unit),
  ListTerm,
  StructTerm, 
  TupleTerm,
  LowerId => Box::new(Expr::Var(<>)),
  "(" <Expr> ")",
};

// -------------------- Patterns -------------------- 

ConsPattern: Box<Pattern> = {
  <PatternTerm> "::" <ConsPattern> => Box::new(Pattern::Cons(<>)),
  PatternTerm
};

ListPattern: Box<Pattern> = {
  "[]" => Box::new(Pattern::List(Vec::new())),
  "[" <e: Pattern> <mut v: ("," <Pattern>)*> "]" => {
    v.insert(0, e);
    Box::new(Pattern::List(v))
  }
}

TuplePattern: Box<Pattern> = {
  "(" <e: Pattern> <mut v: ("," <Pattern>)+> ")" => {
    v.insert(0, e);
    Box::new(Pattern::Tuple(v))
  }
};

PatternTerm: Box<Pattern> = {
  "_" => Box::new(Pattern::Underscore),
  True => Box::new(Pattern::True),
  False => Box::new(Pattern::False),
  Int => Box::new(Pattern::Int(<>)),
  Float => Box::new(Pattern::Float(<>)),
  String => Box::new(Pattern::String(<>)),
  Unit => Box::new(Pattern::Unit),
  TuplePattern, 
  ListPattern,
  "(" <Pattern> ")",
}

Pattern: Box<Pattern> = ConsPattern;

// -------------------- Expressions -------------------- 

OpExpr = OrExpr;

BlockTerm: Box<Expr> = {
  LetExpr,
  <e: Expr> ";" => e
};

BlockExpr: Box<Expr> =  {
  "{" <mut v: BlockTerm*> <r: Expr> "}" => {
    v.push(r);
    Box::new(Expr::Block(v))
  }
};

IfExpr: Box<Expr> = {
  "if" <e1: Expr> <e2: BlockExpr> "else" <e3: BlockExpr> => Box::new(Expr::If(e1, e2, e3))
};

FnArg: (String, Box<Type>) = {
  "(" <i: LowerId> ":" <t: Type> ")" => (i, t),
  // Add pattern variants for Lists, Tuples, Streams
};

FnArgList: Vec<(String, Box<Type>)> = {
  <a: FnArg> <mut v: ("," <FnArg>)*> => {
    v.insert(0, a);
    v
  },
};

FnExpr: Box<Expr> = {
  "fn" Unit "->" <e: Expr> => Box::new(Expr::Fn(vec![("_".to_string(), Box::new(Type::Unit))], e)),
  "fn" <a: FnArgList> "->" <e: Expr> => Box::new(Expr::Fn(a, e)),
};

FixExpr: Box<Expr> = {
  "fix" <LowerId> "->" <Expr> => Box::new(Expr::Fix(<>)),
};

MatchItem: (Box<Pattern>, Box<Expr>) = {
  <Pattern> "=>" <Expr> => (<>),
};

MatchExpr: Box<Expr> = {
  "match" <e: Expr> "{" <c: MatchItem> <mut v: ("," <MatchItem>)*> "}" => {
      v.insert(0, c);
      Box::new(Expr::Match(e, v))
    }
};

pub Expr: Box<Expr> = {
  OpExpr,
  BlockExpr,
  IfExpr,
  FnExpr,
  FixExpr,
  MatchExpr,
};

// -------------------- Top-Level Expressions -------------------- 

LetExpr: Box<Expr> = {
  "let" <i: LowerId> "=" <e: Expr> ";" => Box::new(Expr::Let(i, e))
};

GenericParam: (bool, String) = {
  "#" <UpperId> => (true, <>),
  UpperId => (false, <>),
};

GenericParams: Vec<(bool, String)> = {
  "<" <p: GenericParam> <mut v: ("," <GenericParam>)*> ">" => {
    v.insert(0, p);
    v
  }
};

TypeExpr: Box<Expr> = {
  "type" <i: UpperId> "=" <t: Type> ";" => Box::new(Expr::Type(i, Vec::new(), t)),
  "type" <i: UpperId> <v: GenericParams> "=" <t: Type> ";" => Box::new(Expr::Type(i, v, t)),
};

VariantItem: (String, Option<Box<Type>>) = {
  <i: UpperId> ":" <t: Type?> ","=> (i, t),
};

VariantList: Vec<(String, Option<Box<Type>>)> = {
  <v: VariantItem*> => v,
  <mut v: VariantItem*> <i: UpperId> <t: Type?>  => {
    v.push((i,t));
    v
  },
};

StructDefItem: (String, Box<Type>) = {
  <i: LowerId> ":" <t: Type> ","=> (i, t)
};

StructDefList: Vec<(String, Box<Type>)> = {
  <v: StructDefItem*> => v,
  <mut v: StructDefItem*> <i: LowerId> ":" <t: Type>  => {
    v.push((i,t));
    v
  },
};

StructExpr: Box<Expr> = {
  "struct" <i: UpperId> "{" <v: StructDefList> "}" => Box::new(Expr::Struct(i, Vec::new(), v)),
  "struct" <i: UpperId> <p: GenericParams> "{" <v: StructDefList> "}" => 
    Box::new(Expr::Struct(i, p, v)),
};

EnumExpr: Box<Expr> = {
  "enum" <i: UpperId> "{" <v: VariantList> "}" => Box::new(Expr::Enum(i, Vec::new(), v)),
  "enum" <i: UpperId> <p: GenericParams> "{" <v: VariantList> "}" => Box::new(Expr::Enum(i, p, v)),
}

pub Item: Box<Expr> = {
  LetExpr,
  TypeExpr,
  EnumExpr,
  StructExpr,
}
